import numpy as np
import qiskit as qs


def Rot(qc, phi=0, theta=0, omega=0, wires=0):
    qc.rz(phi, wires)
    qc.rx(theta, wires)
    qc.rz(omega, wires)

def encode_input(W_in, x):
    encoded = np.dot(W_in, x)
    phi, theta, omega = encoded
    return phi, theta, omega

def ReuploadingBlock(input_data,
                     n_qubits,
                     context_length,
                     repeat_blocks,
                     seed=0):
    np.random.seed(seed)
    assert n_qubits % 2 == 0, "n_qubits must be even"

    q_mem = qs.circuit.QuantumRegister(n_qubits, "q")
    qc = qs.QuantumCircuit(q_mem, name="QRNN")

    # readout qubits = odd indices
    readout_idx = [i for i in range(n_qubits) if i % 2 == 1]
    register_names = []

    # loop over timesteps
    for t_index in range(input_data.shape[0]):
        # Create GHZ
        # qc.h(0)
        # for i in range(0, n_qubits - 1):
        #     qc.cx(i, i + 1)
        # repeat block encoding
        for _ in range(repeat_blocks):
            index = 0
            for k in range(0, n_qubits, 2):
                # encode inputs into three scalars per qubit
                input = input_data[t_index]
                phi = input[index]
                theta = input[index + 1]
                omega = input[index + 2]
                phi2 = input[index + 3]
                theta2 = input[index + 4]
                omega2 = input[index + 5]

                # first rotations
                Rot(qc, phi, theta, omega, wires=k)
                Rot(qc, phi2, theta2, omega2, wires=k + 1)

                qc.cx(k, k + 1)

                # second rotations
                Rot(qc, phi, theta, omega, wires=k)
                Rot(qc, phi2, theta2, omega2, wires=k + 1)

                qc.cry(input[index + 6], k, k + 1)

                # third rotations
                Rot(qc, phi, theta, omega, wires=k)
                Rot(qc, phi2, theta2, omega2, wires=k + 1)

                qc.crx(input[index + 7], k, k + 1)
                index += 8
            # entangling layer
            for k in range(0, n_qubits):
                qc.crz(input[index], k, (k + 1) % n_qubits)
                index += 1

            
        # classical register for this timestep
        qc.barrier()
        reg_name = f"cr_{t_index}"
        register_names.append(reg_name)
        c_reg = qs.circuit.ClassicalRegister(n_qubits // 2, reg_name)
        qc.add_register(c_reg)

        # mid-circuit measure + reset
        qc.measure(readout_idx, c_reg)
        qc.reset(readout_idx)
        qc.barrier()

    return qc, register_names
